#!/bin/bash

##
# openvpn-server-setup designed to help OpenVPN server setup on CentOS 6, CentOS 7,
# Ubuntu 16.04 and experimental support of Ubuntu 18.04.
# It can be used for stock openvpn server configuration.
# For customizations you still need manually tune configuration.
#
# You can execute this script on remote host via ssh:
#   ssh user@host 'sudo bash -s' -- <'/local/path/to/openvpn-server-setup'
# Or copy to remote host and run:
#   sudo bash /path/to/openvpn-server-setup [-i IFNAME] [--mssfix [VAL]] [--fragment [VAL]]
#
# By default this script creates configurations with default `mssfix` and
# `fragment` options which is fine in most cases. BTW you can set the value
# you want by commandline option, particularly `mssfix 0` which can lead to
# high packets fragmentation which by-turn can lead to bandwidth and latency
# issues, but it's much more resistant to VPN-tracking by external web-sites
# and do not requre manual TAP adapter MTU fixing on Windows (which isrequired
# by tun-mtu or link-mtu).
#
# In all cases you can change this behavior after creation by modifying server
# and client configs.
#
# openvpn-manage configuration tool embedded to this script and will be
# available after setup. It helps you to manage openvpn users.
##


## Defaults
SERVER_LOCAL_IF='eth0'
mssfix=';mssfix 1450'
fragment=';fragment 1450'

## The content of openvpn-manage script
read -rd '' OPENVPN_MANAGE <<'EOF_OPENVPN_MANAGE'
#!/bin/bash

SCRIPT_VERSION='0.7.4'

read -rd '' HELP <<'EOF'
Description:
    This tool created to support user management for specific openvpn server setup
    by openvpn-server-setup tool.

    Some script terms:
    - host: the name of specific host (specific host can have several clients/certs).
    - client: specific vpn-client/cert for the host.

Usage:
    openvpn-manage ACTION { PARAMS } [ OPTIONS ]
    ACTION := { usage | help | create | append | enable | disable | revoke | list | show }
    OPTIONS := { -f CONF | -t CLIENT_TYPE | -s IP/CIDR | -c COUNT | -o CLIENT_OS | -e | -d | -v }
    CLIENT_TYPE := { user | router }
    CLIENT_OS := { windows | nix }

    openvpn-manage { create | append } HOST_NAME [ OPTIONS ]

    openvpn-manage { enable | disable | revoke } { host HOST_NAME | client CLIENT_NAME }

    openvpn-manage list { host[s] | client[s] } [ HOST_NAME ] { -t CLIENT_TYPE | -s CLIENT_SUBNET_BEHIND | -e | -d }

    openvpn-manage show { host HOST_NAME | client CLIENT_NAME }

Actions:
    create host HOST_NAME
    append client HOST_NAME
        Used for create/append clients to HOST_NAME.
        Difference is:
        validation - you can't create host if HOST_NAME already exist and you can't
            append clients to non-existent host.
        subnet applying for type router - for "append" if -s not specified additional clients of
            the host will have the same subnet as first available iroute option
            in first available client config.

    enable, disable, revoke
        You can enable/disable/revoke specific client (client CLIENT_NAME) or all clients
        (host HOST_NAME) of the host.
        Enable and disable just delete/add 'disable' line to client config, so client can't
        connect. Host/client can be enabled/disabled any time.
        revoke adds client[s] cert[s] to revocation list, so it could be treated as
        persistent client deactivation.
        Note: revoked cert still can be unrevoked manually, but it's not supported
        by openvpn-manage.

    list
        List hosts or clients depends on filter options.
        For HOST_NAME grep standard regexp's supported.
        Examples:
            List all hosts:
                list hosts
            List all routers clients:
                list clients -t router
            List enabled clients of specific host with specified internal subnet:
                list clients HOST_NAME -e -s 10.10.0.8/29

Options:
    -f CONF
        Configuration file of openvpn-manage
        Default: /etc/openvpn/server/scripts/openvpn-manage.conf

    -t CLIENT_TYPE
        Could be "user" (default) or "router". Difference is client config options.
        User config contain push "route ..." to the routers internal subnets.
        Router config contain iroute to internal subnet behind it.

    -s CLIENT_SUBNET_BEHIND
        Format: IP/CIDR. Subnet behind the router. Valid only if CLIENT_TYPE is "router".
        If no subnet specified subnet will be incremented from the last saved subnet.
        Subnet will be saved to LAST_IROUTE_SUBNET_FILE. If no file exist
        INITIAL_IROUTE_SUBNET will be used and then saved to LAST_IROUTE_SUBNET_FILE.
        Subnet will be saved only if -s option omitted, so manually specified subnet
        will not be saved in LAST_IROUTE_SUBNET_FILE. It's allow manually specify
        subnet without interrupt existing subnet chain.

    -c COUNT
        Default is 1. Allow to create COUNT clients/certs for the host with single
        command. Additional host clients/certs could be added via action "append"
        next time.

    -e, -d
        List enabled/disabled only.

    -z {0 | 1}
        If 1 create zip packs (default: 0).

    -r REMOTE_IP[:REMOTE_PORT]
        Overwrite config REMOTE_IP and optionally REMOTE_PORT variables

    -v {default | debug | none | conf}
        Set stdout verbosity:
            debug: verbose output
            default: normal output
            none: completely quite, only errrors can be print to stderr
            conf: print only single generated config content for action "create"
EOF


##
# Exit with optional message to stderr
##
quit() {
    [[ $2 ]] && echo "$2" >&2
    exit "${1:-0}"
}


##
# Convert decimal number to IPv4 address
##
dec2ip() {
    local _var _res _e _octet _dec
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    _dec=$1
    for _e in {3..0}; do
        (( _octet = _dec/256**_e ))
        (( _dec -= _octet*256**_e ))
        _res+=.${_octet}
    done
    _res=${_res:1}

    if [[ ${_var} ]]; then printf -v "${_var}" '%s' "${_res}"; else echo "${_res}"; fi
}


##
# Convert IPv4 address to decimal number
##
ip2dec() {
    local _var _res _a _b _c _d
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    IFS=. read -r _a _b _c _d <<<"$1"
    (( _res = _a*256**3 + _b*256**2 + _c*256 + _d ))

    if [[ ${_var} ]]; then printf -v "${_var}" '%s' "${_res}"; else echo "${_res}"; fi
}


##
# Convert IPv4 MASK to CIDR
# Assumes that MASK have no gaps.
##
mask2cidr() {
    local _var _res _x
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    _x=${1##*255.}
    set -- 0^^^128^192^224^240^248^252^254^ $(( (${#1}-${#_x})*2 )) "${_x%%.*}"
    _x=${1%%$3*}
    (( _res = $2 + ${#_x}/4 ))

    if [[ ${_var} ]]; then printf -v "${_var}" '%s' "${_res}"; else echo "${_res}"; fi
}


##
# Convert CIDR to IPv4 MASK
##
cidr2mask() {
    local _var _res
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi
    [[ -z $1 ]] && set 0

    set -- $(( 5-($1/8) )) 255 255 255 255 $(( (255<<(8 - ($1%8)))&255 )) 0 0 0
    if (($1 > 1)); then shift "$1"; else shift; fi
    _res=${1:-0}.${2:-0}.${3:-0}.${4:-0}

    if [[ ${_var} ]]; then printf -v "${_var}" '%s' "${_res}"; else echo "${_res}"; fi
}


##
# Return next subnet with the same size
# Subnet format is IPv4/CIDR
##
increment_subnet() {
    local _var _res _ip _cidr _size _ip_dec _ip_next
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi

    _ip=${1%/*}
    _cidr=${1#*/}
    (( _size = 2**(32-_cidr) ))  # all IPs count inside subnet e.g. /29 size is 8
    ip2dec -v _ip_dec "${_ip}"
    dec2ip -v _ip_next $((_size+_ip_dec))
    _res=${_ip_next}/${_cidr}

    if [[ ${_var} ]]; then printf -v "${_var}" '%s' "${_res}"; else echo "${_res}"; fi
}


##
# Validate IPv4 address
# Note: this is invalid address: 192.168.000.001
##
validate_ip4() {
    local _re
    _re='^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'
    [[ "$1" =~ ${_re} ]] && return 0 || return 1
}


##
# Validate IPv4/CIDR
##
validate_ip4cidr() {
    local _re
    _re='^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\/([0-9]|[1-2][0-9]|3[0-2])$'
    [[ "$1" =~ ${_re} ]] && return 0 || return 1
}


##
# Usage: validate_host_name host_name [regex]
##
validate_host_name() {
    local _re
    if [[ $2 ]]; then
        _re=$2
    elif [[ ${HOST_NAME_ALLOWED_REGEX} ]]; then
        _re=${HOST_NAME_ALLOWED_REGEX}
    else
        _re='^[A-Za-z0-9_-]+$'  # Default regex
    fi
    [[ "$1" =~ ${_re} ]] || quit 1 "Host name restricted to match the following regex: ${_re}"
    return 0
}


##
# Validate that client name starts with 5 digits and '-' then.
# Values '00000-' and '00001-' treated as invalid.
# Include host name validation.
##
validate_client_name() {
    local _re _N
    _re='^[0-9]+-$'
    _N=${1::6}
    [[ "${_N}" =~ ${_re} && "${_N}" != '00000-' && "${_N}" != '00001-' ]] || quit 1 "First 6 symbols of client name must match the following regex: ${_re}"
    validate_host_name "${1:6}" || return 1
    return 0
}


##
# Attempt to kill client connection on both tcp and udp servers if management interface is enabled
##
kill_existing_client_connection() {
    local _cn
    _cn=$1
    if [[ -n "${TCP_MANAGEMENT_SOCKET}" && -S "${TCP_MANAGEMENT_SOCKET}" ]]; then
        # Kill existing connection if any
        sudo -u "${TCP_MANAGEMENT_USER}" -g "${TCP_MANAGEMENT_GROUP}" nc -U "${TCP_MANAGEMENT_SOCKET}" <<<"kill ${_cn}" >/dev/null
        # TODO: implement for TCP_MANAGEMENT_IP:TCP_MANAGEMENT_PORT
    fi
    if [[ -n "${UDP_MANAGEMENT_SOCKET}" && -S "${UDP_MANAGEMENT_SOCKET}" ]]; then
        # Kill existing connection if any
        sudo -u "${UDP_MANAGEMENT_USER}" -g "${UDP_MANAGEMENT_GROUP}" nc -U "${UDP_MANAGEMENT_SOCKET}" <<<"kill ${_cn}" >/dev/null
        # TODO: implement for UDP_MANAGEMENT_IP:UDP_MANAGEMENT_PORT
    fi
    return 0 # Always return 0
}


revoke_cert() {
    local _cn
    _cn=$1
    [[ -f "${EASYRSA}/pki/issued/${_cn}.crt" ]] || quit 1 "No such cert: ${_cn}"
    if ! grep -qE "^R[[:space:]]*[[:digit:]]*Z.*/CN=${_cn}(/.*)?$" "${EASYRSA}/pki/index.txt"; then
        ./easyrsa --batch revoke "${_cn}" &>"${DESCRIPTOR}"
        if (($?)); then
            quit 1 "${_cn}: failed to revoke cert"
        else
            # TODO: after killing connection crl-verify file is still not updated so client may have enough time to reconnect (?)
            kill_existing_client_connection "${_cn}"
            echo "${_cn}: cert revoked"
        fi
    else
        echo "${_cn}: cert already revoked!"
    fi
}


disable_client() {
    local _cn
    _cn=$1
    if ! grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${_cn}"; then
        echo disable >>"${CLIENT_CONFIG_DIR}/${_cn}"
        kill_existing_client_connection "${_cn}"
        echo "${_cn}: disabled"
    else
        echo "${_cn}: was already disabled!"
    fi
}


enable_client() {
    local _cn
    _cn=$1
    if grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${_cn}"; then
        sed -i '/^disable$/d' "${CLIENT_CONFIG_DIR}/${_cn}"
        echo "${_cn}: enabled"
    else
        echo "${_cn}: was already enabled!"
    fi
}


populate_subnet_var() {
    local _cn CLIENT_SUBNET_BEHIND_IP CLIENT_SUBNET_BEHIND_CIDR ROUTERS_LIST FIRST_ROUTER
    _cn=$1
    ROUTERS_LIST=$(exec -c grep -l '^iroute ' "${CLIENT_CONFIG_DIR}/"*"-${_cn}")
    if (($? == 0)); then  # Other routers exists for this host
        # Get subnet from first available router config of this host!
        read -r FIRST_ROUTER <<<"${ROUTERS_LIST}"
        CLIENT_SUBNET_BEHIND=$(exec -c grep -m1 '^iroute ' "${FIRST_ROUTER}")
        CLIENT_SUBNET_BEHIND=${CLIENT_SUBNET_BEHIND#iroute }
        CLIENT_SUBNET_BEHIND_IP=${CLIENT_SUBNET_BEHIND%% *}
        mask2cidr -v CLIENT_SUBNET_BEHIND_CIDR ${CLIENT_SUBNET_BEHIND#* }
        CLIENT_SUBNET_BEHIND=${CLIENT_SUBNET_BEHIND_IP}/${CLIENT_SUBNET_BEHIND_CIDR}
    else  # It's only router for this host: autoincrement subnet
        # Increment last saved subnet
        if [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]]; then
            increment_subnet -v CLIENT_SUBNET_BEHIND "$(< "${LAST_IROUTE_SUBNET_FILE}")"
        else
            CLIENT_SUBNET_BEHIND=${INITIAL_IROUTE_SUBNET}
        fi
        [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]] && mv "${LAST_IROUTE_SUBNET_FILE}"{,.old}
        echo "${CLIENT_SUBNET_BEHIND}" >"${LAST_IROUTE_SUBNET_FILE}"
        echo "Note: LAST_IROUTE_SUBNET was incremented to ${CLIENT_SUBNET_BEHIND}" >&2
    fi
}


update_client() {
    # Update client type and/or subnet
    local _cn OLD_CLIENT_TYPE OLD_IROUTE CLIENT_SUBNET_BEHIND_IP CLIENT_SUBNET_BEHIND_MASK OLD_CLIENT_SUBNET_BEHIND OLD_CLIENT_SUBNET_BEHIND_IP OLD_CLIENT_SUBNET_BEHIND_CIDR
    _cn=$1
    if grep -q '^iroute ' "${CLIENT_CONFIG_DIR}/${_cn}"; then
        OLD_CLIENT_TYPE=router
        OLD_IROUTE=$(exec -c grep -m1 '^iroute ' "${CLIENT_CONFIG_DIR}/${_cn}")
        OLD_CLIENT_SUBNET_BEHIND=${OLD_IROUTE#iroute }
        OLD_CLIENT_SUBNET_BEHIND_IP=${OLD_CLIENT_SUBNET_BEHIND%% *}
        mask2cidr -v OLD_CLIENT_SUBNET_BEHIND_CIDR ${OLD_CLIENT_SUBNET_BEHIND#* }
        OLD_CLIENT_SUBNET_BEHIND=${OLD_CLIENT_SUBNET_BEHIND_IP}/${OLD_CLIENT_SUBNET_BEHIND_CIDR}
    else
        OLD_CLIENT_TYPE=user
    fi

    case "${CLIENT_TYPE}" in
        user)
            if [[ "${CLIENT_TYPE}" != "${OLD_CLIENT_TYPE}" ]]; then  # router -> user
                sed -i -e '/^iroute /d' -e "1 a config ${USERS_CONF_IN_CHROOT}" "${CLIENT_CONFIG_DIR}/${_cn}"
                echo "${_cn}: type changed to ${CLIENT_TYPE}"
            else  # user -> user: nothing to change
                echo "${_cn}: type is already ${CLIENT_TYPE}!"
            fi
            ;;
        router)
            if [[ -z "${CLIENT_SUBNET_BEHIND}" ]]; then
                populate_subnet_var "${_cn:6}"
            fi

            CLIENT_SUBNET_BEHIND_IP=${CLIENT_SUBNET_BEHIND%%/*}
            cidr2mask -v CLIENT_SUBNET_BEHIND_MASK ${CLIENT_SUBNET_BEHIND#*/}
            if [[ "${CLIENT_TYPE}" != "${OLD_CLIENT_TYPE}" ]]; then  # user -> router
                sed -i -e '/^config /d' -e "1 a iroute ${CLIENT_SUBNET_BEHIND_IP} ${CLIENT_SUBNET_BEHIND_MASK}" "${CLIENT_CONFIG_DIR}/${_cn}"
                echo "${_cn}: internal subnet changed to ${CLIENT_SUBNET_BEHIND}"
            else  # router -> router: change router subnet only
                if [[ "${OLD_CLIENT_SUBNET_BEHIND}" != "${CLIENT_SUBNET_BEHIND}" ]]; then
                    sed -i "s/${OLD_IROUTE}/iroute ${CLIENT_SUBNET_BEHIND_IP} ${CLIENT_SUBNET_BEHIND_MASK}/" "${CLIENT_CONFIG_DIR}/${_cn}"
                    echo "${_cn}: internal subnet changed to ${CLIENT_SUBNET_BEHIND}"
                else
                    echo "${_cn}: already has internal subnet ${CLIENT_SUBNET_BEHIND}!"
                fi
            fi
            ;;
    esac

    # Enable/disable if -e|-d specified
    [[ "${ENABLED}" == yes ]] && enable_client "${_cn}"
    [[ "${ENABLED}" == no ]] && disable_client "${_cn}"
}


show_client() {
    local CLIENT_NAME ENABLED VALID_CERT CLIENT_TYPE IROUTES IROUTE IP CIDR USERS_CONF_LINE line n N SUBNET CLIENT_CONFIG CCC
    SUBNET=''
    CLIENT_NAME=$1
    CLIENT_CONFIG="${CLIENT_CONFIG_DIR}/${CLIENT_NAME}"
    CCC=$(< "${CLIENT_CONFIG}")

    if grep -q '^disable$' <<<"${CCC}"; then
        ENABLED=no
    else
        ENABLED=yes
    fi

    IROUTES=$(exec -c grep '^iroute ' <<<"${CCC}")
    if (($? == 0)); then
        CLIENT_TYPE=router
        while read IROUTE; do
            IROUTE=${IROUTE#iroute }
            IP=${IROUTE%% *}
            mask2cidr -v CIDR ${IROUTE#* }
            [[ ${SUBNET} ]] && SUBNET+=','
            SUBNET+="${IP}/${CIDR}"
        done <<<"${IROUTES}"
    fi
    USERS_CONF_LINE=$(exec -c grep "^config ${USERS_CONF_IN_CHROOT}$" <<<"${CCC}")
    if (($? == 0)); then
        CLIENT_TYPE=user
    fi
    if [[ -n "${IROUTES}" && -n "${USERS_CONF_LINE}" ]]; then
        CLIENT_TYPE=mixed
    elif [[ -z "${IROUTES}" && -z "${USERS_CONF_LINE}" ]]; then
        CLIENT_TYPE=unspecified
    fi

    (( N = 10#${CLIENT_NAME::5} ))
    n=0
    while read line; do
        ((n++))
        if [[ ${n} -eq ${N} ]]; then
            if [[ "${line::1}" == 'R' ]]; then
                VALID_CERT=no
            else
                VALID_CERT=yes
            fi
            break
        fi
    done <"${EASYRSA}/pki/index.txt"

    echo "${CLIENT_NAME}:
    Server side config: ${CLIENT_CONFIG}
    Enabled: ${ENABLED}
    Valid cert: ${VALID_CERT}
    Type: ${CLIENT_TYPE}"
    if [[ "${CLIENT_TYPE}" == 'router' || "${CLIENT_TYPE}" == 'mixed' ]]; then
        echo "    Internal subnets: ${SUBNET}"
    fi
    if [[ "${CLIENT_TYPE}" == 'user' || "${CLIENT_TYPE}" == 'mixed' ]]; then
        echo "    Users shared config: ${USERS_CONF}"
    fi
}


add_client() {
    local HOST_NAME FLNUMBER NUMBER USER CLIENT_CONFIG_NAME DEC_IP srv TMP_USER_DIR OVPN_CONF_CONTENT
    HOST_NAME=$1
    printf -v FLNUMBER '%05d' $(( 16#$(< "${EASYRSA}/pki/serial") ))
    (( NUMBER = 10#${FLNUMBER} ))
    USER="${FLNUMBER}-${HOST_NAME}"
    case "${CLIENT_OS}" in
        windows)
            CLIENT_CONFIG_NAME="${USER}.ovpn"
            eval "read -rd '' OS_SPECIFIC_OPTIONS <<EOFOSO${BR}# ${NIX_SPECIFIC_OPTIONS//${BR}/${BR}# }${BR}${BR}${WIN_SPECIFIC_OPTIONS}${BR}EOFOSO"
            ;;
        *)
            CLIENT_CONFIG_NAME="${USER}.conf"
            eval "read -rd '' OS_SPECIFIC_OPTIONS <<EOFOSO${BR}${NIX_SPECIFIC_OPTIONS}${BR}${BR}# ${WIN_SPECIFIC_OPTIONS//${BR}/${BR}# }${BR}EOFOSO"
    esac

    cd "${EASYRSA}"

    ./easyrsa --batch --req-cn="${USER}" gen-req "${USER}" nopass &>"${DESCRIPTOR}" || quit 1 "Easyrsa error: $?"
    ./easyrsa --batch --req-cn="${USER}" sign-req client "${USER}" &>"${DESCRIPTOR}" || quit 1 "Easyrsa error: $?"

    # Change CN in Authority Key Identifier DirName for compatibility with Netcomm routers openvpn interface
    sed -i -e "s|/CN=server/|/CN=${USER}/|" -e "s|/CN=server$|/CN=${USER}|" "${EASYRSA}/pki/issued/${USER}.crt"

    # Calculate client OVPN IP and NETMASK
    srv=$(exec -c grep -m1 '^server ' "${SERVER_CONF}")
    srv=${srv#server }
    srv=${srv% nopool*}
    ip2dec -v DEC_IP ${srv%% *}
    dec2ip -v CLIENT_OVPN_IP $((DEC_IP+NUMBER))
    NETMASK=${srv#* }

    ## Number for ethN and tunN, first host cert will have N=0, 2nd - N=1 etc.
    N=$(ls -1 "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}" 2>/dev/null | wc -l)

    # Create symlinks if possible, copy otherwise
    if ln -s "${EASYRSA}/pki/issued/${USER}.crt" "${CLIENT_KEYS_DIR}" >/dev/null; then
        ln -s "${EASYRSA}/pki/private/${USER}.key" "${CLIENT_KEYS_DIR}"
    else
        cp "${EASYRSA}/pki/issued/${USER}.crt" "${EASYRSA}/pki/private/${USER}.key" "${CLIENT_KEYS_DIR}"
    fi
    echo "ifconfig-push ${CLIENT_OVPN_IP} ${NETMASK}" >"${CLIENT_CONFIG_DIR}/${USER}"

    case "${CLIENT_TYPE}" in
        user)
            echo "config ${USERS_CONF_IN_CHROOT}" >>"${CLIENT_CONFIG_DIR}/${USER}"
        ;;
        router)
            CLIENT_SUBNET_BEHIND_IP=${CLIENT_SUBNET_BEHIND%%/*}
            cidr2mask -v CLIENT_SUBNET_BEHIND_MASK ${CLIENT_SUBNET_BEHIND#*/}
            echo "iroute ${CLIENT_SUBNET_BEHIND_IP} ${CLIENT_SUBNET_BEHIND_MASK}" >>"${CLIENT_CONFIG_DIR}/${USER}"
            ROUTER_CONF_STR='# On config creation time vpn-server used the following internal subnet for this client:'
            ROUTER_CONF_STR+="# ${CLIENT_SUBNET_BEHIND}"
            ROUTER_CONF_STR+='# It should match real internal subnet if you want allow vpn-users access it.'
            ROUTER_CONF_STR+='# Forwarding should be enabled for vpn<->subnet interfaces.'
        ;;
    esac

    if [[ ${D} ]]; then
        disable_client "${USER}"
    fi

    chown :"${OPENVPN_GROUP}" "${CLIENT_CONFIG_DIR}/${USER}"
    chmod 640 "${CLIENT_CONFIG_DIR}/${USER}"

    # chown :${OPENVPN_GROUP} "${EASYRSA}/pki/index.txt"
    # chmod 640 "${EASYRSA}/pki/index.txt"
    # chmod og+x "${EASYRSA}/pki"{,/issued,/private}

    # cp "${EASYRSA}/pki/issued/${USER}.crt" "${EASYRSA}/pki/private/${USER}.key" "${KEYS_DIR}/ca.crt" "${KEYS_DIR}/ta.key" temp
    mkdir -p "${CLIENT_PACKS_DIR}/${HOST_NAME}"

    # Write client config
    eval "read -rd '' CLIENT_CONFIG <<EOF${BR}${CLIENT_CONFIG_TEMPLATE}${BR}EOF"
    echo "${CLIENT_CONFIG}" >"${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}"
    chown -R :sudo "${CLIENT_PACKS_DIR}/${HOST_NAME}"
    # (set -o posix; set) >&2

    # .zip pack beside all-in-one config
    # Include:
    #     ${USER}.tgz with ca.crt ${USER}.key ${USER}.crt
    #     ta.key
    #     ${USER} all-in-one conf
    if ((CREATE_ZIP)); then
        TMP_USER_DIR="/tmp/openvpn-manage/${USER}"
        mkdir -p "${TMP_USER_DIR}"
        tar --transform 's/.*\///g' -zchf "${TMP_USER_DIR}/${USER}.tgz" "./pki/private/${USER}.key" "./pki/issued/${USER}.crt" ./pki/ca.crt &>"${DESCRIPTOR}"
        cp -l ./pki/ta.key "${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}" "${TMP_USER_DIR}/" &>"${DESCRIPTOR}" || \
            cp ./pki/ta.key "${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}" "${TMP_USER_DIR}/" &>"${DESCRIPTOR}"
        zip -rjD "${CLIENT_PACKS_DIR}/${HOST_NAME}/${USER}.zip" "${TMP_USER_DIR}/" &>"${DESCRIPTOR}"
        rm "${TMP_USER_DIR}/"{"${USER}.tgz",ta.key,"${CLIENT_CONFIG_NAME}"} &>"${DESCRIPTOR}" && rm -r "${TMP_USER_DIR}/" &>"${DESCRIPTOR}"

        [[ ${DESCRIPTOR} == /dev/null ]] || echo "${BR}${BR}"
    fi

    if [[ "${VERB}" == conf ]]; then
        read -rd '' OVPN_CONF_CONTENT <"${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}"
        echo "${OVPN_CONF_CONTENT}"
    elif [[ "${VERB}" == none ]]; then
        :
    else
        echo "${USER}: config created:${BR}${CLIENT_PACKS_DIR}/${HOST_NAME}/${CLIENT_CONFIG_NAME}"
    fi
    cd - >/dev/null
}


create_host() {
    local HOST_NAME COUNT INCSUB
    HOST_NAME=$1
    [[ $2 ]] && COUNT=$2 || COUNT=1
    if (( COUNT <= 0 )); then
        quit 1 "Invalid COUNT: ${COUNT}"
    fi

    for ((n=1;n<=COUNT;++n)); do
        INCSUB=no  # Is subnet was incremented?
        if [[ "${CLIENT_TYPE}" == router ]]; then
            if [[ -z "${CLIENT_SUBNET_BEHIND}" ]]; then
                # Increment last saved subnet
                if [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]]; then
                    increment_subnet -v CLIENT_SUBNET_BEHIND "$(< "${LAST_IROUTE_SUBNET_FILE}")"
                else
                    CLIENT_SUBNET_BEHIND=${INITIAL_IROUTE_SUBNET}
                fi
                INCSUB=yes
            fi
            if [[ -z "${S}" ]]; then  # If not specified in command line
                validate_ip4cidr "${CLIENT_SUBNET_BEHIND}" || quit 1 "Invalid subnet: ${CLIENT_SUBNET_BEHIND}"
            fi
        fi

        add_client "${HOST_NAME}"

        if [[ $? -eq 0 && "${INCSUB}" == yes ]]; then
            [[ -f "${LAST_IROUTE_SUBNET_FILE}" ]] && mv "${LAST_IROUTE_SUBNET_FILE}"{,.old}
            echo "${CLIENT_SUBNET_BEHIND}" >"${LAST_IROUTE_SUBNET_FILE}"
            echo "Note: LAST_IROUTE_SUBNET was incremented to ${CLIENT_SUBNET_BEHIND}" >&2
        fi
        if [[ "${CLIENT_TYPE}" == router ]]; then
            echo "Router internal subnet set to ${CLIENT_SUBNET_BEHIND}"
        fi
        echo
    done

    if ((CREATE_ZIP)); then
        zip --exclude \*.zip -rjD "${CLIENT_PACKS_DIR}/${HOST_NAME}.zip" "${CLIENT_PACKS_DIR}/${HOST_NAME}/" >/dev/null
        [[ "${VERB}" == default || "${VERB}" == debug ]] && \
        echo "${BR}Host pack with client configs created:${BR}${CLIENT_PACKS_DIR}/${HOST_NAME}.zip"
    fi
}


find_client_names() {
    # Return array of client names for specified host_name
    local _var _res _host_name _filename
    if [[ $1 == '-v' ]]; then _var=$2; shift 2; fi
    _res=()
    _host_name=$1
    for _filename in "${CLIENT_PACKS_DIR}/${_host_name}/"*.{ovpn,conf}; do
        _filename=${_filename##*/}
        _filename=${_filename%.ovpn}
        _filename=${_filename%.conf}
        [[ "${_filename}" == '*' ]] && continue
        _res+=("${_filename}")
    done

    if [[ ${_var} ]]; then eval "${_var}=(\${_res[@]})"; else echo "${_res[@]}"; fi
}


BR=$'\n'


# Main case: Parse positional arguments
case "$1" in
    ''|help) quit 255 "${HELP}";;

    *)  # Parse args, verify, apply defaults.
        # Really not for all actions root required, but to be sure...
        # ((UID)) && quit 2 'Root privileges required'

        [[ $2 ]] || quit 1 "Action requires parameter!"
        unset HELP

        ## Defaults
        DESCRIPTOR=/dev/null  # Default if no -v option specified
        CONF='/etc/openvpn/server/scripts/openvpn-manage.conf'
        CREATE_ZIP=0  # Do not create zip archives

        # Options below can be overwrited in CONF file
        # CA_PASS=no  # 'yes' if CA is password protected
        SERVER_DIR='/etc/openvpn/server'
        KEYS_DIR="${SERVER_DIR}/keys"
        CLIENT_KEYS_DIR="${SERVER_DIR}/client-keys"
        CLIENT_PACKS_DIR="${SERVER_DIR}/client-packs"
        CLIENT_CONFIG_DIR="${SERVER_DIR}/client-configs"
        USERS_CONF="${SERVER_DIR}/users-config"
        UDP_SERVER_CONF='/etc/openvpn/udp.server.conf'
        TCP_SERVER_CONF='/etc/openvpn/tcp.server.conf'
        if [[ -f "${UDP_SERVER_CONF}" ]]; then
            SERVER_CONF="${UDP_SERVER_CONF}"
        elif [[ -f "${TCP_SERVER_CONF}" ]]; then
            SERVER_CONF="${TCP_SERVER_CONF}"
        else
            SERVER_CONF='/etc/openvpn/server.conf'
        fi
        EASYRSA='/etc/openvpn/easy-rsa/easyrsa3'
        CLIENT_OS_DEFAULT='nix'  # 'nix' for Unix-based OS, 'windows' for Windows
        OPENVPN_USER=openvpn
        OPENVPN_GROUP=openvpn
        INITIAL_IROUTE_SUBNET='10.10.0.0/29'
        LAST_IROUTE_SUBNET_FILE="${SERVER_DIR}/last_iroute_subnet"
        HOST_NAME_ALLOWED_REGEX='^[A-Za-z0-9_-]+$'
        ALLOW_DIFFERENT_CLIENT_TYPES_FOR_HOST=no
        ## END Defaults

        ## Parse options
        # Calculate first option position
        for ((i=1;i<=$#;++i)); do
            if [[ "${!i::1}" == '-' ]]; then
                OPTIND=$i
                break
            fi
        done
        while getopts ":edt:o:s:c:f:v:z:r:" OPT; do
            [[ "${OPTARG::1}" = '-' ]] && quit 1 "Option argument can not start with '-'"
            case "$OPT" in
                v) VERB=${OPTARG}; V='-v';
                    [[ "${VERB}" == debug ]] && DESCRIPTOR=/dev/stdout
                    ;;
                e) ENABLED=yes; E='-e';;
                d) ENABLED=no; D='-d';;
                t) CLIENT_TYPE=${OPTARG}; T='-t';;
                o) CLIENT_OS=${OPTARG}; O='-o';
                    case "${CLIENT_OS}" in
                        linux|mac|bsd) CLIENT_OS=nix;;
                        windows|nix) ;;
                        *) quit 1 "Invalid OS: ${CLIENT_OS}${BR}"'Have to be "windows" or "nix" (for Linux/Mac/BSD/etc). "linux", "mac", "bsd" translated to "nix".'
                    esac
                    ;;
                s) CLIENT_SUBNET_BEHIND=${OPTARG}; S='-s';
                    validate_ip4cidr "${CLIENT_SUBNET_BEHIND}" || quit 1 "Invalid subnet: ${CLIENT_SUBNET_BEHIND}"
                    ;;
                c) COUNT=${OPTARG};;
                f) CONF=${OPTARG};;
                z) [[ "${OPTARG}" == 1 ]] && CREATE_ZIP=1 || CREATE_ZIP=0;;
                r) REMOTE=${OPTARG}
                    # It also could be domain, so
                    # validate_ip4 "${REMOTE%%:*}" || quit 1 "Invalid IP on -r option value: ${REMOTE}"
                    ;;
                :) quit 1 "Option -$OPTARG requires an argument";;
                *) quit 1 "Invalid option: -$OPTARG";;
            esac
        done
        # OPTIND=1

        # Import configuration file
        . "${CONF}"
        (($?)) && quit 1 "Failed to import configuration file: ${CONF}"
        # echo "${CLIENT_CONFIG_TEMPLATE}" >&2

        # Set variables of for -r option
        if [[ -n ${REMOTE} ]]; then
            [[ ${REMOTE%%:*} ]] && REMOTE_IP=${REMOTE%%:*}
            [[ ${REMOTE##*:} =~ ^[0-9]+$ ]] && REMOTE_PORT=${REMOTE##*:}
        fi

        CHROOT=$(exec -c grep -m1 '^chroot ' "${SERVER_CONF}")
        CHROOT=${CHROOT#chroot }
        if [[ -n "${CHROOT}" && "${CHROOT}" != '/' ]]; then
            USERS_CONF_IN_CHROOT=${USERS_CONF##*/}  # E.g. users-config
        else
            USERS_CONF_IN_CHROOT=${USERS_CONF}
        fi

        # Verification of config options
        [[ -d "${CHROOT}" ]] || quit 1 "Chroot server dir have to exist for current configuration: ${CHROOT}"
        [[ -d "${SERVER_DIR}" ]] || quit 1 "Server dir does not exist: ${SERVER_DIR}"
        [[ -d "${KEYS_DIR}" ]] || quit 1 "Keys dir does not exist: ${KEYS_DIR}"
        [[ -d "${CLIENT_KEYS_DIR}" ]] || quit 1 "Clients keys dir does not exist: ${CLIENT_KEYS_DIR}"
        [[ -d "${CLIENT_PACKS_DIR}" ]] || quit 1 "Clients packages dir dir does not exist: ${CLIENT_PACKS_DIR}"
        [[ -d "${CLIENT_CONFIG_DIR}" ]] || quit 1 "Clients config dir dir does not exist: ${CLIENT_CONFIG_DIR}"
        [[ -f "${USERS_CONF}" ]] || quit 1 "Users shared config file does not exist: ${USERS_CONF}"
        [[ -f "${SERVER_CONF}" ]] || quit 1 "OpenVPN server config file does not exist: ${SERVER_CONF}"
        [[ -d "${EASYRSA}" ]] || quit 1 "EASYRSA dir does not exist: ${EASYRSA}"
        [[ -f "${EASYRSA}/pki/crl.pem" ]] || quit 1 "Certificate revocation list file does not exist: ${EASYRSA}/pki/crl.pem"
        getent passwd "${OPENVPN_USER}" &>/dev/null || quit 1 "No such user: ${OPENVPN_USER}"
        getent group "${OPENVPN_GROUP}" &>/dev/null || quit 1 "No such group: ${OPENVPN_GROUP}"


        [[ -z ${CLIENT_OS} ]] && CLIENT_OS=${CLIENT_OS_DEFAULT}

        if [[ -n $E && -n $D ]]; then
            quit 1 "Options -e and -d can not be specified simultaneously!"
        fi

        case "${CLIENT_TYPE}" in
            '') CLIENT_TYPE=user;;
            user|router) ;;
            *) quit 1 "Invalid argument for -t option: ${CLIENT_TYPE}";;
        esac

        if [[ -n "${S}" && "${CLIENT_TYPE}" != router ]]; then
            quit 1 "Subnet can be specified for type \"router\" only"
        fi

        case "${COUNT}" in
            '') COUNT=1;;
            *[^0-9]*) quit 1 "Invalid COUNT: ${COUNT}";;
        esac

        # Set openvpn management interface variables
        UDP_MANAGEMENT_SOCKET=''
        UDP_MANAGEMENT_IP=''
        UDP_MANAGEMENT_PORT=''
        UDP_MANAGEMENT_PWFILE=''
        UDP_MANAGEMENT_USER='root'
        UDP_MANAGEMENT_GROUP='root'
        if [[ -f "${UDP_SERVER_CONF}" ]]; then
            while read -a cflarr || [[ -n "${cflarr}" ]]; do
                if [[ "${cflarr[0]}" == 'management' ]]; then
                    UDP_MANAGEMENT_PWFILE=${cflarr[3]}
                    if [[ "${cflarr[2]}" == unix ]]; then
                        UDP_MANAGEMENT_SOCKET=${cflarr[1]}
                    else
                        UDP_MANAGEMENT_IP=${cflarr[1]}
                        UDP_MANAGEMENT_PORT=${cflarr[2]}
                    fi
                elif [[ "${cflarr[0]}" == 'management-client-user' ]]; then
                    UDP_MANAGEMENT_USER=${cflarr[1]}
                elif [[ "${cflarr[0]}" == 'management-client-group' ]]; then
                    UDP_MANAGEMENT_GROUP=${cflarr[1]}
                fi
            done <"${UDP_SERVER_CONF}"
        fi
        TCP_MANAGEMENT_SOCKET=''
        TCP_MANAGEMENT_IP=''
        TCP_MANAGEMENT_PORT=''
        TCP_MANAGEMENT_PWFILE=''
        TCP_MANAGEMENT_USER='root'
        TCP_MANAGEMENT_GROUP='root'
        if [[ -f "${TCP_SERVER_CONF}" ]]; then
            while read -a cflarr || [[ -n "${cflarr}" ]]; do
                if [[ "${cflarr[0]}" == 'management' ]]; then
                    TCP_MANAGEMENT_PWFILE=${cflarr[3]}
                    if [[ "${cflarr[2]}" == unix ]]; then
                        TCP_MANAGEMENT_SOCKET=${cflarr[1]}
                    else
                        TCP_MANAGEMENT_IP=${cflarr[1]}
                        TCP_MANAGEMENT_PORT=${cflarr[2]}
                    fi
                elif [[ "${cflarr[0]}" == 'management-client-user' ]]; then
                    TCP_MANAGEMENT_USER=${cflarr[1]}
                elif [[ "${cflarr[0]}" == 'management-client-group' ]]; then
                    TCP_MANAGEMENT_GROUP=${cflarr[1]}
                fi
            done <"${TCP_SERVER_CONF}"
        fi
        ;;&

    create)
        HOST_NAME=$2
        [[ ${HOST_NAME} ]] || quit 1 "You have to specify HOST_NAME"
        validate_host_name "${HOST_NAME}"
        if [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]]; then
            quit 1 "Host already exist: ${HOST_NAME}${BR}Use \"append\" to append clients to existing host."
        fi
        ;;&

    append)
        HOST_NAME=$2
        [[ ${HOST_NAME} ]] || quit 1 "You have to specify HOST_NAME"
        validate_host_name "${HOST_NAME}"
        if ! [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]]; then
            quit 1 "Host does not exist: ${HOST_NAME}${BR}Use 'create' to create new host."
        fi

        for i in "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}"; do FIRST_CLIENT_CONFIG_FILE=$i; break; done
        if grep -q '^iroute ' "${FIRST_CLIENT_CONFIG_FILE}"; then
            # Use the same client type as other clients has
            CLIENT_TYPE_PREVIOUS=router
        else
            CLIENT_TYPE_PREVIOUS=user
        fi
        if [[ "${CLIENT_TYPE_PREVIOUS}" != "${CLIENT_TYPE}" ]]; then
            if [[ "${ALLOW_DIFFERENT_CLIENT_TYPES_FOR_HOST}" == yes ]]; then
                if [[ ${T} ]]; then  # Specified in command line explicitly
                    [[ ${V} ]] && echo "Warning: Client type specified in command line doesn't match the type of previous clients for this host!" &>"${DESCRIPTOR}"
                else
                    CLIENT_TYPE=${CLIENT_TYPE_PREVIOUS}
                fi
            else
                [[ $T ]] && quit 1 "Client type specified in command line doesn't match the type of previous clients for this host!${BR}Remove it or specify proper type."
                CLIENT_TYPE=${CLIENT_TYPE_PREVIOUS}
            fi
        fi
        if [[ "${CLIENT_TYPE}" == router && -z "${S}" ]]; then
            populate_subnet_var "${HOST_NAME}"
        fi

        # Reuse previous CLIENT_OS if commandline option '-o' ommited
        for i in "${CLIENT_PACKS_DIR}/${HOST_NAME}/"*[np][fn]; do FIRST_EXT=${i##*.}; break; done
        if [[ -z "$O" ]]; then
            if [[ "${FIRST_EXT}" == 'ovpn' ]]; then
                CLIENT_OS=windows
            else
                CLIENT_OS=nix
            fi
        fi
        ;;&

    create|append)
        [[ -z ${CLIENT_CONFIG_TEMPLATE} ]] && quit 1 'CLIENT_CONFIG_TEMPLATE variable required, you have to set it in configuration file.'
        create_host "${HOST_NAME}" "${COUNT}"
        ;;

    enable|disable|revoke|update|show)
        case "$2" in
            client)
                CLIENT_NAME=$3
                [[ ${CLIENT_NAME} ]] || quit 1 "You have to specify CLIENT_NAME"
                validate_client_name "${CLIENT_NAME}"
                if ! [[ -f "${CLIENT_CONFIG_DIR}/${CLIENT_NAME}" ]]; then
                    quit 1 "No such client or client config is absent: ${CLIENT_NAME}"
                fi
                ;;
            host)
                HOST_NAME=$3
                [[ ${HOST_NAME} ]] || quit 1 "You have to specify HOST_NAME"
                validate_host_name "${HOST_NAME}"
                if ! [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]]; then
                    quit 1 "No such host: ${HOST_NAME}"
                fi
                ;;
            *) quit 1 "Invalid parameter: $2"
        esac
        ;;&

    enable)
        case "$2" in
            client)
                enable_client "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do enable_client "${cn}"; done
                echo "${BR}All clients of ${HOST_NAME} was enabled"
                ;;
        esac
        ;;

    disable)
        case "$2" in
            client)
                disable_client "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do disable_client "${cn}"; done
                echo "${BR}All clients of ${HOST_NAME} was disabled"
                ;;
        esac
        ;;

    revoke)
        cd "${EASYRSA}"
        case "$2" in
            client)
                revoke_cert "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do revoke_cert "${cn}"; done
                echo "${BR}All certs of ${HOST_NAME} was revoked"
                ;;
        esac
        if ./easyrsa --batch gen-crl &>"${DESCRIPTOR}"; then
            echo "Revocation list was updated"
        else
            quit 1 "Failed to update revocation list!"
        fi
        chown :"${OPENVPN_GROUP}" "${EASYRSA}/pki/crl.pem"
        chmod 440 "${EASYRSA}/pki/crl.pem"
        if [[ -d /etc/openvpn/chroot ]]; then
            rm -f /etc/openvpn/chroot/crl.pem  # Workaround for CentOS which ignore -f option for cp
            cp -pfT "${EASYRSA}/pki/crl.pem" /etc/openvpn/chroot/crl.pem
        fi
        # chown :${OPENVPN_GROUP} "${EASYRSA}/pki/index.txt"
        # chmod 640 "${EASYRSA}/pki/index.txt"
        # chmod g+x "${EASYRSA}/pki"
        cd - >/dev/null
        ;;

    update)  # Update type and/or subnet
        case "$2" in
            client)
                update_client "${CLIENT_NAME}"
                ;;
            host)
                # quit 254 "Update all host clients feature does not implemented yet. Use it with single client."
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do update_client "${cn}"; done
                echo "${BR}All clients of ${HOST_NAME} was updated"
                ;;
        esac
        ;;

    list)  # TODO: finish
        case "$2" in
            clients|client)
                OUT=$(ls -1 "${CLIENT_CONFIG_DIR}" | grep -v '^DEFAULT$')  # All clients/certs
                if [[ -z $3 ]]; then
                    if [[ -n "${OUT}" ]]; then echo "${OUT}"; else quit 1 "No clients match!"; fi
                    exit 0
                elif [[ "${3::1}" != '-' ]]; then
                    # Filter by HOST_NAME
                    HOST_NAME=$3
                    OUT=$(exec -c grep "^[[:digit:]]*-${HOST_NAME}$" <<<"${OUT}")
                    [[ -n "${OUT}" ]] || quit 1 "No clients match!"
                    # [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]] || quit 1 "No such host: ${HOST_NAME}"
                    # ls -1 "${CLIENT_CONFIG_DIR}" | grep "^[[:digit:]]*-${HOST_NAME}$"
                    # find "${CLIENT_CONFIG_DIR}" -maxdepth 1 -mindepth 1 -type f -name "[0-9]+-$3" -printf "%f\n"  | awk -F / '{print $NF}' | cut -d- -f2- | sort -u
                fi

                # Filter by options
                if [[ $T ]]; then
                    case "${CLIENT_TYPE}" in
                        router)
                            OUT=$(while read client; do
                                    grep -q '^iroute ' "${CLIENT_CONFIG_DIR}/${client}" && echo "${client}";
                                done <<<"${OUT}")
                            ;;
                        user)
                            OUT=$(while read client; do
                                    grep -q '^iroute ' "${CLIENT_CONFIG_DIR}/${client}" || echo "${client}";
                                done <<<"${OUT}")
                            ;;
                    esac
                fi
                if [[ $D ]]; then
                    OUT=$(while read client; do
                            grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${client}" && echo "${client}";
                        done <<<"${OUT}")
                elif [[ $E ]]; then
                    OUT=$(while read client; do
                            grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${client}" || echo "${client}";
                        done <<<"${OUT}")
                fi
                if [[ $S ]]; then
                    IP=${CLIENT_SUBNET_BEHIND%%/*}
                    cidr2mask -v MASK ${CLIENT_SUBNET_BEHIND#*/}
                    OUT=$(while read client; do
                            grep -q "^iroute ${IP} ${MASK}" "${CLIENT_CONFIG_DIR}/${client}" && echo "${client}";
                        done <<<"${OUT}")
                fi
                # if [[ $O ]]; then
                #     # Can be manually changed by user, so skip implementing this filter.
                # fi

                if [[ -n "${OUT}" ]]; then echo "${OUT}"; else quit 1 "No clients match!"; fi
                ;;
            hosts|host)
                OUT=$(ls -1 "${CLIENT_CONFIG_DIR}" | grep -v '^DEFAULT$' | cut -d- -f2- | sort -u)  # All hosts
                if [[ -z $3 ]]; then
                    if [[ -n "${OUT}" ]]; then echo "${OUT}"; else quit 1 "No hosts match!"; fi
                    exit 0
                elif [[ "${3::1}" != '-' ]]; then
                    # Filter by HOST_NAME
                    HOST_NAME=$3
                    OUT=$(exec -c grep "^${HOST_NAME}$" <<<"${OUT}")
                    [[ -n "${OUT}" ]] || quit 1 "No hosts match!"
                fi

                # Filter by options
                if [[ $T ]]; then
                    case "${CLIENT_TYPE}" in
                        router)
                            OUT=$(while read HOST_NAME; do
                                    grep -q '^iroute ' "$(ls -1 "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}" | head -1)" \
                                    && echo "${HOST_NAME}";
                                done <<<"${OUT}")
                            ;;
                        user)
                            OUT=$(while read HOST_NAME; do
                                    grep -q '^iroute ' "$(ls -1 "${CLIENT_CONFIG_DIR}"/*-"${HOST_NAME}" | head -1)" \
                                    || echo "${HOST_NAME}";
                                done <<<"${OUT}")
                            ;;
                    esac
                fi
                if [[ $D ]]; then
                    # The host treated as disabled if all its clients disabled
                    quit 254 "-d filter for hosts is not implemented yet"
                    # OUT=$(while read HOST_NAME; do
                    #         grep -q '^disable$' "${CLIENT_CONFIG_DIR}/${client}" && echo "${HOST_NAME}";
                    #     done <<<"${OUT}")
                elif [[ $E ]]; then
                    # The host treated as enabled if at least one of its clients enabled
                    quit 254 "-e filter for hosts is not implemented yet"
                fi
                if [[ $S ]]; then
                    quit 254 "-s filter for hosts is not implemented yet"
                fi

                if [[ -n "${OUT}" ]]; then
                    echo "${OUT}"
                else
                    quit 1 "No hosts match!"
                fi
                ;;
            *) quit 1 "Invalid parameter: $2"
        esac
        ;;

    show)
        case "$2" in
            client)
                show_client "${CLIENT_NAME}"
                ;;
            host)
                find_client_names -v client_names "${HOST_NAME}"
                for cn in "${client_names[@]}"; do show_client "${cn}"; echo; done
                ;;
        esac
        ;;

    rename)  ## Dirty hack
        OLD_HOST_NAME=$2
        HOST_NAME=$3
        [[ -n  ${HOST_NAME} && -n ${OLD_HOST_NAME} ]] || quit 1 "You have to specify source and destination hostname"
        validate_host_name "${HOST_NAME}"
        if ! [[ -d "${CLIENT_PACKS_DIR}/${OLD_HOST_NAME}" ]]; then
            quit 1 "Source host does not exist: ${OLD_HOST_NAME}"
        fi
        if [[ -d "${CLIENT_PACKS_DIR}/${HOST_NAME}" ]]; then
            quit 1 "Destination host already exist: ${HOST_NAME}"
        fi

        read -r N_HEX CN <<<$(grep -m1 -E "/CN=[0-9]{5}-${OLD_HOST_NAME}/" "${EASYRSA}/pki/index.txt" | cut -d$'\t' -f4,6)
        CN=${CN##*/CN=}; CN=${CN%%-*}-${OLD_HOST_NAME}
        FLN=${CN%%-*}

        OLD_USER=${CN}
        USER=${FLN}-${HOST_NAME}

        # Create user in cloned dir
        mkdir -p /tmp/openvpn-manage/$$
        cp -ra "${EASYRSA}" /tmp/openvpn-manage/$$
        cd "/tmp/openvpn-manage/$$/${EASYRSA##*/}"
        sed -i 's|/etc/openvpn/easy-rsa/easyrsa3|"$PWD"|g' vars
        ./easyrsa --batch --req-cn="${USER}" gen-req "${USER}" nopass &>"${DESCRIPTOR}" || quit 1 "Easyrsa error: $?"
        ./easyrsa --batch --req-cn="${USER}" sign-req client "${USER}" &>"${DESCRIPTOR}" || quit 1 "Easyrsa error: $?"
        # Change CN in Authority Key Identifier DirName for compatibility with Netcomm routers openvpn interface
        sed -i -e "s|/CN=server/|/CN=${USER}/|" -e "s|/CN=server$|/CN=${USER}|" "pki/issued/${USER}.crt"

        ## Applying changes to original folder
        # Replace key, req, crt
        mv "pki/private/${USER}.key" "${EASYRSA}/pki/private/"
        mv "pki/reqs/${USER}.req" "${EASYRSA}/pki/reqs/"
        mv "pki/issued/${USER}.crt" "${EASYRSA}/pki/issued/"
        rm -f "${EASYRSA}/pki/private/${OLD_USER}.key" \
              "${EASYRSA}/pki/reqs/${OLD_USER}.req" \
              "${EASYRSA}/pki/issued/${OLD_USER}.crt"
        # Change certs_by_serial
        mv "$(exec -c grep -m1 -l "CN=${USER}" ./pki/certs_by_serial/*.pem)" "${EASYRSA}/pki/certs_by_serial/${N_HEX}.pem"
        # Change index.txt
        sed -i "s|^$(exec -c grep -m1 "CN=${OLD_USER}" "${EASYRSA}/pki/index.txt")|$(grep -m1 "CN=${USER}" "pki/index.txt" | sed "s|\t15\tunknown|\t${N_HEX}\tunknown|")|" "${EASYRSA}/pki/index.txt"
        # Rename files/folders
        mv /etc/openvpn/server/client-packs/{${OLD_HOST_NAME},${HOST_NAME}} &&
        mv /etc/openvpn/server/client-packs/${HOST_NAME}/{${OLD_USER},${USER}}.conf
        mv /etc/openvpn/server/client-keys/{${OLD_USER},${USER}}.key
        mv /etc/openvpn/server/client-keys/{${OLD_USER},${USER}}.crt
        mv /etc/openvpn/chroot/ccd/{${OLD_USER},${USER}}
        # Change client config
        read -rd '' USER_CONFIG <<EOFUSER_CONFIG
$(exec -c sed \
    -e "s|for host \"${OLD_HOST_NAME}\"|for host \"${HOST_NAME}\"|" \
    -e "s|^remote [^ ]\+ [0-9]\+|remote ${REMOTE_IP} ${REMOTE_PORT}|g" \
    -e '/^<cert>$/,$d' \
    "/etc/openvpn/server/client-packs/${HOST_NAME}/${USER}.conf")
<cert>
$(< "${EASYRSA}/pki/issued/${USER}.crt")
</cert>
<key>
$(< "${EASYRSA}/pki/private/${USER}.key")
</key>
key-direction 1
<tls-auth>
$(< "${SERVER_DIR}/keys/ta.key")
</tls-auth>
EOFUSER_CONFIG
        echo "${USER_CONFIG}" >"/etc/openvpn/server/client-packs/${HOST_NAME}/${USER}.conf"
        chown -R :sudo "/etc/openvpn/server/client-packs/${HOST_NAME}"

        cd - >/dev/null
        rm -rf /tmp/openvpn-manage/$$

        if "${EASYRSA}/easyrsa" --batch gen-crl &>"${DESCRIPTOR}"; then
            echo "Revocation list was updated"
        else
            quit 1 "Failed to update revocation list!"
        fi
        chown :"${OPENVPN_GROUP}" "${EASYRSA}/pki/crl.pem"
        chmod 440 "${EASYRSA}/pki/crl.pem"

        if [[ "${VERB}" == conf ]]; then
            echo "${USER_CONFIG}"
        elif [[ "${VERB}" == none ]]; then
            :
        else
            echo "Host renamed: ${OLD_HOST_NAME} -> ${HOST_NAME}"
            echo "Now you have to use updated user config because certs was changed: /etc/openvpn/server/client-packs/${HOST_NAME}/${USER}.conf"
        fi
        # quit 1 "This action is not implemented yet."
        ;;

    version|--version) quit 255 "${SCRIPT_VERSION}";;

    *)                                                                                                                                                                                                                 EE=${BR}${BR}'But don'$'\'''t be upset! Pet the croco and go ahead to eat some cookies!'$'\n'; KOTEHOK=$'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x2e\x2e\x2d\x2d\x27\x27\x60\x60\x2d\x2d\x2d\x2e\x2e\x2e\x2e\x5f\x5f\x5f\x20\x20\x20\x5f\x2e\x2e\x2e\x5f\x20\x20\x20\x20\x5f\x5f\x0a\x2f\x2f\x2f\x20\x2f\x2f\x5f\x2e\x2d\x27\x20\x20\x20\x20\x2e\x2d\x2f\x22\x3b\x20\x20\x60\x20\x20\x20\x20\x20\x20\x20\x20\x60\x60\x3c\x2e\x5f\x20\x20\x60\x60\x2e\x27\x27\x5f\x20\x60\x2e\x20\x2f\x20\x2f\x2f\x20\x2f\x0a\x2f\x2f\x2f\x5f\x2e\x2d\x27\x20\x5f\x2e\x2e\x2d\x2d\x2e\x27\x5f\x20\x20\x20\x20\x5c\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x60\x28\x20\x29\x20\x29\x20\x2f\x2f\x20\x2f\x2f\x0a\x2f\x20\x28\x5f\x2e\x2e\x2d\x27\x20\x2f\x2f\x20\x28\x3c\x20\x5f\x20\x20\x20\x20\x20\x3b\x5f\x2e\x2e\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x3b\x20\x60\x27\x20\x2f\x20\x2f\x2f\x2f\x0a\x2f\x20\x2f\x2f\x20\x2f\x2f\x20\x2f\x2f\x20\x20\x60\x2d\x2e\x5f\x2c\x5f\x29\x27\x20\x2f\x2f\x20\x2f\x20\x60\x60\x2d\x2d\x2e\x2e\x2e\x5f\x5f\x5f\x5f\x2e\x2e\x2d\x27\x20\x2f\x2f\x2f\x20\x2f\x20\x2f\x2f\x27\x0a'; HEKOTEHOK=$'\x20\x20\x20\x20\x20\x20\x5f\x3d\x2c\x5f\x0a\x20\x20\x20\x6f\x5f\x2f\x36\x20\x2f\x23\x20\x20\x20\x5c\x5f\x5f\x20\x7c\x23\x23\x2f\x0a\x20\x20\x20\x20\x3d\x27\x7c\x2d\x2d\x20\x20\x20\x20\x20\x20\x2f\x20\x20\x20\x23\x27\x2d\x2e\x0a\x20\x20\x20\x20\x20\x20\x5c\x23\x7c\x5f\x20\x20\x20\x5f\x27\x2d\x2e\x20\x2f\x0a\x20\x20\x20\x20\x20\x20\x20\x7c\x2f\x20\x5c\x5f\x28\x20\x23\x20\x7c\x22\x0a\x20\x20\x20\x20\x20\x20\x43\x2f\x20\x2c\x2d\x2d\x5f\x5f\x5f\x2f\x0a'; if ((1$(exec -c date +%N)%2)); then EE+=${KOTEHOK}; else EE+=${HEKOTEHOK}; fi  # Easter egg
        quit 1 "This action is not implemented yet.${EE}"
        ;;
esac

exit 0
EOF_OPENVPN_MANAGE


##
# Exit with optional message to stderr
##
quit() {
    [[ $2 ]] && echo "$2" >&2
    exit "${1:-0}"
}


##
# Validate IPv4 address
# Note: this is invalid address: 192.168.000.001
##
validate_ip4() {
    local _re
    _re='^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'
    [[ "$1" =~ ${_re} ]] && return 0 || return 1
}


((UID)) && quit 1 "You are not root. Try: sudo $0 $*"
BR=$'\n'  # Newline alias


## Set options if specified
while [[ -n "$1" ]]; do
    opt=$1
    shift
    if [[ ${opt::1} == '-' ]]; then  # First arg is an option
        opt=${opt#${opt%%[^-]*}}  # Remove leading hyphens
    else
        quit 1 "Option must start with -"
    fi
    case "${opt}" in
        mssfix)
            mssfix='mssfix'
            if [[ "$1" =~ ^[0-9]+$ ]]; then
                mssfix+=" $(($1))"
                shift
            elif [[ ${1::1} == '-' ]]; then
                :
            elif [[ $1 == '' ]]; then
                shift
            fi
            ;;
        fragment) fragment='fragment'
            if [[ "$1" =~ ^[0-9]+$ ]]; then
                fragment+=" $(($1))"
                shift
            elif [[ ${1::1} == '-' ]]; then
                :
            elif [[ $1 == '' ]]; then
                shift
            fi
            ;;
        i|interface)
            if [[ -n $1 ]] && [[ -L "/sys/class/net/$1" ]]; then
                SERVER_LOCAL_IF=$1
                shift
            else
                quit 1 "No such interface: $1"
            fi
            ;;
        # ip|local) ;;  # TODO
        *) quit 1 "No such option: ${opt}";;
    esac
done
# declare -p mssfix fragment SERVER_LOCAL_IF; exit

## Set time sync
if hash timedatectl 2>/dev/null; then  # Systemd is in use
    echo 'Enable time sync with NTP servers using timedatectl'
    timedatectl set-ntp yes  # TODO: handle the case when ntpd configured in the system, this have to be no in this case
# else  # Most probably sysv is in use, sync by ntpd will be configured later
fi

## Check OS
if [[ -f /etc/redhat-release ]]; then
    OS_family=RedHat

    ## Get CentOS major version
    CentOS_major=$(exec -c sed -n 's/.* \([0-9]\+\)\.\?.*/\1/p' /etc/redhat-release)

    if ! ((CentOS_major == 6 || CentOS_major == 7)); then
        quit 1 'Only CentOS 6 & 7 supported for RedHat family, check your CentOS version in /etc/redhat-release'
    fi
    echo "CentOS major version detected: ${CentOS_major}"

    OS=CentOS

    ## You could want to upgrade the system to latest state if it's created from scratch
    # yum -y -d0 upgrade

    case "${CentOS_major}" in
        7)
            echo 'Adding epel repo'
            rpm -ivh --replacepkgs "http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm"
            (($?==0)) || quit 1 'Failed to add epel repo'

            echo 'Disable and stop firewalld if exists'
            systemctl disable firewalld
            systemctl stop firewalld
            echo 'Install, start and enable iptables-services'
            yum -y -d0 install iptables-services
            systemctl enable iptables
            systemctl start iptables
            ;;
        6)
            ## Be sure that time is in sync (for OSes with systemd it's already done)
            echo 'Setup time sync using ntpd'
            yum -y -d0 install ntp
            chkconfig ntpd on
            ntpdate pool.ntp.org
            service ntpd start
            # ntpq -p

            echo 'Fix ancient ca-certs'
            yum --disablerepo=epel -y -d1 update ca-certificates

            echo 'Adding epel repo'
            rpm -ivh --replacepkgs "http://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm"
            (($?==0)) || quit 1 'Failed to install epel repo'
            # echo 'Changing epel repo to use http instead of https because of ancient ca-certs'
            # sed -i 's|https://|http://|g' /etc/yum.repos.d/epel*.repo
            ;;
    esac
    (($?==0)) || quit 1 'Failed to install epel repo'
elif [[ -f /etc/debian_version ]]; then
    OS_family=Debian
    if grep -q ' bionic ' /etc/apt/sources.list; then
        OS=Ubuntu
        OS_release=Bionic
    elif grep -q ' xenial ' /etc/apt/sources.list; then
        OS=Ubuntu
        OS_release=Xenial
    else
        quit 1 'Only Ubuntu Xenial 16.04 and Bionic 18.04 supported for Debian family'
    fi
else
    quit 1 'Unsupported OS family'
fi


case "${OS_family}" in
    RedHat)
        echo 'Installing required packages'
        yum -y -d0 install openvpn zip unzip iptables iproute bind-utils wget openssl netcat-openbsd
        (($?==0)) || quit 1 'Failed to install required packages'
        ;;
    Debian)
        if [[ "${OS_release}" != Bionic ]]; then
            echo 'Add official openvpn repo'  # See https://community.openvpn.net/openvpn/wiki/OpenvpnSoftwareRepos
            wget -nv -O - https://swupdate.openvpn.net/repos/repo-public.gpg | apt-key add -
            echo "deb http://build.openvpn.net/debian/openvpn/stable ${OS_release,,} main" >/etc/apt/sources.list.d/openvpn-aptrepo.list
        fi
        echo 'Updating packages list'
        apt-get -yqq update
        echo 'Installing required packages'
        apt-get -yq install openvpn zip unzip iptables iproute2 wget dnsutils openssl netfilter-persistent iptables-persistent netcat-openbsd
        ;;
esac
(($?==0)) || quit 1 'Failed to install required packages'

echo 'Check openvpn version (should be >=2.4)'
openvpn --version | head -1
(($?==0)) || quit 1 'Failed to check openvpn version'

SERVER_LOCAL_IP=$(ip address show "${SERVER_LOCAL_IF}" | sed -n 's/ \+inet \([0-9.]\+\).*/\1/p' 2>/dev/null | grep -v 127.0.0.1 | head -1)
echo 'Existing host IPv4 non-local interfaces:'
# hostname -I
ip -o -4 address | grep -v -e ': lo ' -e ': tun[0-9]\+ ' -e ': tap[0-9]\+ '
if [[ -z ${SERVER_LOCAL_IP} ]]; then
    echo "Cannot detect local IP for ${SERVER_LOCAL_IF} interface."
    echo -n "Input local IP for desired interface and press enter: "
    read SERVER_LOCAL_IP
    if ! grep -q " inet ${SERVER_LOCAL_IP}/" < <(exec -c ip -o -4 address); then
        quit 1 "No such local IP assigned to any interface: ${SERVER_LOCAL_IP}"
    fi
    SERVER_LOCAL_IF=$(ifconfig | grep -B1 "inet addr:${SERVER_LOCAL_IP}" | awk '$1!="inet" && $1!="--" {print $1}' | cut -d: -f1)
fi
echo "Server local interface name: ${SERVER_LOCAL_IF}"
echo "Server local IP for openvpn server: ${SERVER_LOCAL_IP}"
# Server public IP or domain
SERVER_PUBLIC_IP=$(dig -4 -b "${SERVER_LOCAL_IP}" +short +time=3 +retry=1 myip.opendns.com @208.67.222.222)
if ! validate_ip4 "${SERVER_PUBLIC_IP}"; then
    echo "Cannot detect public IP of interface ${SERVER_LOCAL_IF}"
    echo -n 'Input interface name: '
    read SERVER_LOCAL_IF
    if ! [[ -L "/sys/class/net/${SERVER_LOCAL_IF}" ]]; then
        quit 1 "No such interface: ${SERVER_LOCAL_IF}"
    fi
    echo -n 'Input local IP: '
    read SERVER_LOCAL_IP
    if ! grep -q " inet ${SERVER_LOCAL_IP}/" < <(exec -c ip address); then
        quit 1 "No such local IP assigned to any interface: ${SERVER_LOCAL_IP}"
    fi
    SERVER_PUBLIC_IP=$(dig -4 -b "${SERVER_LOCAL_IP}" +short +time=3 +retry=1 myip.opendns.com @208.67.222.222)
    if ! validate_ip4 "${SERVER_PUBLIC_IP}"; then
        echo -n "Cannot detect public IP of interface ${SERVER_LOCAL_IF}"
        echo -n "Input public IP: "
        read SERVER_PUBLIC_IP
    fi
else
    echo "Server public IP detected: ${SERVER_PUBLIC_IP}"
fi

## Change work dir
mkdir -p /etc/openvpn
cd /etc/openvpn

## Clear some dirs if any
[[ -d /etc/openvpn/server ]]   && rm -rvf /etc/openvpn/server
[[ -d /etc/openvpn/easy-rsa ]] && rm -rvf /etc/openvpn/easy-rsa
[[ -d /etc/openvpn/chroot ]]   && rm -rvf /etc/openvpn/chroot

echo 'Downloading easyrsa pack'
wget -nv https://github.com/vmspike/openvpn-manage/raw/master/easyrsa3.zip  # Better to use your own link for this pack
(($?==0)) || quit 1 'Failed to download easyrsa3.zip pack'
## Alternatively if you have it locally, run from your PC (for Windows you can use MobaXterm or Putty):
# scp ./easyrsa3.zip user@host:~/
## And move to /etc/openvpn on server side:
# mv ~user/easyrsa3.zip /etc/openvpn

## Some actions to setup easyrsa
unzip -q easyrsa3.zip
(($?==0)) || quit 1 'Failed to unzip easyrsa3.zip pack'
rm -f easyrsa3.zip
mv easy-rsa-master easy-rsa
cd /etc/openvpn/easy-rsa/easyrsa3
./easyrsa --batch init-pki

## Will ask for common name if no --batch specified
## Example: Gabriel (default: Easy-RSA CA; batch default: ChangeMe)
./easyrsa --batch build-ca nopass

./easyrsa --batch gen-crl
./easyrsa --batch gen-req server nopass
./easyrsa --batch sign-req server server
./easyrsa --batch gen-dh  # Can take few minutes depends on CPU

## User openvpn already should be present but if not add it
if ! getent passwd openvpn &>/dev/null; then
    case "${OS_family}" in
        RedHat)
            adduser --system --no-create-home --home-dir /etc/openvpn --shell /sbin/nologin --gid openvpn
            ;;
        Debian)
            adduser --system --no-create-home --home /nonexistent --disabled-login --group openvpn
            ;;
    esac
fi

mkdir -p /etc/openvpn/server/{client-configs,client-keys,client-packs,keys,scripts}
openvpn --genkey --secret /etc/openvpn/easy-rsa/easyrsa3/pki/ta.key
ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/ca.crt /etc/openvpn/server/keys/
# ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem /etc/openvpn/server/keys/
ln -s /etc/openvpn/chroot/crl.pem /etc/openvpn/server/keys/
ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/dh.pem /etc/openvpn/server/keys/
ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/issued/server.crt /etc/openvpn/server/keys/
ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/private/server.key /etc/openvpn/server/keys/
ln -s /etc/openvpn/easy-rsa/easyrsa3/pki/ta.key /etc/openvpn/server/keys/ta.key
mkdir -p /var/log/openvpn
chown -R :openvpn /etc/openvpn/server/keys/ /var/log/openvpn /etc/openvpn/easy-rsa/easyrsa3/pki
chmod 400 /etc/openvpn/easy-rsa/easyrsa3/pki/{ca.crt,dh.pem,issued/server.crt,private/server.key,ta.key}
chmod 750 /etc/openvpn/server/keys
chmod 710 /etc/openvpn/easy-rsa/easyrsa3/pki/
chmod 440 /etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem
touch /etc/openvpn/server/{tcp,udp}.server.conf
chown -R root:openvpn /var/log/openvpn
chmod 755 /var/log/openvpn/
ln -s ./server/tcp.server.conf /etc/openvpn/tcp.server.conf
ln -s ./server/udp.server.conf /etc/openvpn/udp.server.conf

## Preparations for openvpn-manage
ln -s /etc/openvpn/server/scripts/openvpn-manage /usr/local/bin/  # So it will be available globally if /usr/localb/in in PATH environmental variable
touch /etc/openvpn/server/users-config
chown :openvpn /etc/openvpn/server/users-config
chmod 640 /etc/openvpn/server/users-config

## Preparations for chrooted environment
mkdir -p /etc/openvpn/chroot/{ccd,tmp,scripts,bin,etc}
chown root:openvpn /etc/openvpn/chroot/tmp
chmod 775 /etc/openvpn/chroot/tmp
cp -pf /etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem /etc/openvpn/chroot/
# ln -s /etc/openvpn/chroot/crl.pem /etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem
touch /etc/openvpn/chroot/scripts/learn-address
chown root:openvpn /etc/openvpn/chroot/scripts/*
chmod 754 /etc/openvpn/chroot/scripts/*
mv /etc/openvpn/server/users-config /etc/openvpn/chroot/
ln -s ../chroot/users-config /etc/openvpn/server/users-config

## Write openvpn-manage
echo "${OPENVPN_MANAGE}" >'/etc/openvpn/server/scripts/openvpn-manage'

chmod +x /etc/openvpn/server/scripts/openvpn-manage
# ln -s /etc/openvpn/server/scripts/openvpn-manage /usr/local/bin/  # Already done

## Preparations for learn-address script (for dual tcp/udp server in chrooted environment)
cd /etc/openvpn/chroot
OPENVPN_GID=$(getent group openvpn | cut -d: -f3)
cat >etc/busybox.conf <<EOFBUSYBOXCONF
[SUID]
# ${OPENVPN_GID} is openvpn group number
iproute = sx- 0.${OPENVPN_GID}
sh = xx- 0.${OPENVPN_GID}
EOFBUSYBOXCONF
wget -nv https://busybox.net/downloads/binaries/1.27.1-i686/busybox_ASH -O bin/sh
wget -nv https://busybox.net/downloads/binaries/1.27.1-i686/busybox_IPROUTE -O bin/iproute
chown root:root etc/busybox.conf bin/iproute
chown root:openvpn bin/sh
chmod 640 etc/busybox.conf
chmod 4755 bin/iproute
chmod 750 bin/sh

## Create suitable /etc/openvpn/easy-rsa/easyrsa3/vars
cp /etc/openvpn/easy-rsa/easyrsa3/vars{.example,}
sed -i \
    -e 's|^#set_var\s\+EASYRSA_TEMP_FILE\s.*|set_var EASYRSA_TEMP_FILE "/dev/shm/extensions.temp"|' \
    -e 's|^#set_var\s\+EASYRSA_CA_EXPIRE\s.*|set_var EASYRSA_CA_EXPIRE 36500|' \
    -e 's|^#set_var\s\+EASYRSA_CERT_EXPIRE\s.*|set_var EASYRSA_CERT_EXPIRE 36500|' \
    -e 's|^#set_var\s\+EASYRSA_CRL_DAYS\s.*|set_var EASYRSA_CRL_DAYS 36500|' \
    -e 's|^#set_var\s\+EASYRSA_REQ_CN\s.*|set_var EASYRSA_REQ_CN "server"|' \
    -e 's|^#set_var\s\+EASYRSA_BATCH\s.*|set_var EASYRSA_BATCH "neveraskmehoney"|' \
    /etc/openvpn/easy-rsa/easyrsa3/vars

## Fix CRL issue when in chroot
# sed -i \
#     -e 's|^crl_dir\s*=\s*$dir|crl_dir\t = /etc/openvpn/chroot|' \
#     -e 's|^crl\s*=\s*$dir|crl\t = /etc/openvpn/chroot|' \
#     /etc/openvpn/easy-rsa/easyrsa3/openssl-1.0.cnf


## Create suitable /etc/openvpn/server/users-config (Used for selectable forwarding)
echo 'push "redirect-gateway def1"
push "dhcp-option DNS 8.8.8.8"
push "dhcp-option DNS 208.67.222.222"
' >/etc/openvpn/server/users-config


## Create configs
# /etc/openvpn/chroot/scripts/learn-address
read -rd '' LEARN_ADDRESS <<'EOF_LEARN_ADDRESS'
#!/bin/sh

##
# This script allows to share the same VPN subnet between TCP and UDP openvpn server
# Sudoers have to be setup to allow openvpn user to change routing table.
#
# This file created to work in chrooted environment using busybox
##


# Operation: "add", "update", or "delete" based on whether or not the address is being added to, modified, or deleted from OpenVPN's internal routing table.
MODE=$1

# Address: The address being learned or unlearned.
# This can be an IPv4 address such as "198.162.10.14",
# an IPv4 subnet such as "198.162.10.0/24",
# or an ethernet MAC address (when --dev tap is being used) such as "00:FF:01:02:03:04".
IP=$2

# Common Name: The common name on the certificate associated with the client linked to this address.
# Only present for "add" or "update" operations, not "delete".
# CN=$3

# Some environmental variables also available, e.g.: dev

case "${MODE}" in
    add|update)
        # exec -c sudo ip route add ${IP} dev ${dev} proto static scope link
        echo "Learn: iproute del ${IP}"
        iproute del ${IP}
        echo "Learn: iproute add ${IP} dev ${dev} proto static scope link"
        iproute add ${IP} dev ${dev} proto static scope link
        ;;
esac
EOF_LEARN_ADDRESS
echo "${LEARN_ADDRESS}" >'/etc/openvpn/chroot/scripts/learn-address'

# /etc/openvpn/server/scripts/openvpn-manage.conf  # Change SERVER_PUBLIC_IP to your server public IP or domain
read -rd '' OPENVPN_MANAGE_CONF <<EOF_OPENVPN_MANAGE_CONF
##
# Configuration file for openvpn-manage.
# Bash syntax required
# Easyrsa 'vars' file have to be properly setup before
##


## Usually you don't need to change these options
# SERVER_DIR='/etc/openvpn/server'
# KEYS_DIR="\${SERVER_DIR}/keys"
# CLIENT_KEYS_DIR="\${SERVER_DIR}/client-keys"
# CLIENT_PACKS_DIR="\${SERVER_DIR}/client-packs"
# CLIENT_CONFIG_DIR="\${SERVER_DIR}/client-configs"
CLIENT_CONFIG_DIR='/etc/openvpn/chroot/ccd'
# USERS_CONF="\${SERVER_DIR}/users-config"
UDP_SERVER_CONF='/etc/openvpn/udp.server.conf'
TCP_SERVER_CONF='/etc/openvpn/tcp.server.conf'
SERVER_CONF=\${UDP_SERVER_CONF}  # If tcp and udp servers subnet are the same, any config is fine here, othervise set the main one.
# EASYRSA='/etc/openvpn/easy-rsa/easyrsa3'
CLIENT_OS_DEFAULT='windows'  # 'nix' for Unix-based OS, 'windows' for Windows
# OPENVPN_USER=openvpn
# OPENVPN_GROUP=openvpn

# CA_PASS='no'  # 'yes' if CA is password protected

## Example of variables which can be used in client config options
## You can also use custom variables specified in this file
# CLIENT_CONFIG_DIR=/etc/openvpn/chroot/ccd
# CLIENT_CONFIG_NAME=00008-win-test.conf
# CLIENT_PACKS_DIR=/etc/openvpn/server/client-packs
# CLIENT_KEYS_DIR=/etc/openvpn/server/client-keys
# CLIENT_OS=nix
# CLIENT_OVPN_IP=172.31.240.8
# CLIENT_TYPE=user
# EASYRSA=/etc/openvpn/easy-rsa/easyrsa3
# FIRST_CLIENT_CONFIG_FILE=/etc/openvpn/chroot/ccd/00006-win-test
# FLNUMBER=00008
# HOST_NAME=win-test
# HOST_NAME_ALLOWED_REGEX='^[A-Za-z0-9_-]+\$'
# INITIAL_IROUTE_SUBNET=10.10.0.0/29
# KEYS_DIR=/etc/openvpn/server/keys
# LAST_IROUTE_SUBNET_FILE=/etc/openvpn/server/last_iroute_subnet
# N=2
# OPENVPN_GROUP=openvpn
# OPENVPN_USER=openvpn
# OS_SPECIFIC_OPTIONS  # WIN_SPECIFIC_OPTIONS or NIX_SPECIFIC_OPTIONS
# SERVER_CONF=/etc/openvpn/udp.server.conf
# SERVER_DIR=/etc/openvpn/server
# USER=00008-win-test
# USERS_CONF=/etc/openvpn/server/users-config
##

## Client config options
# OS_SPECIFIC_OPTIONS will be replaced to NIX_SPECIFIC_OPTIONS or WIN_SPECIFIC_OPTIONS depends on CLIENT_OS
read -rd '' CLIENT_CONFIG_TEMPLATE <<'EOF'
# OpenVPN 2.4 client \${CLIENT_OS} config file \${N} for host "\${HOST_NAME}"

# When  connecting to a remote server do not wait for more than n seconds
# waiting for a response before trying the next server. The default value is 120s.
# This timeout includes proxy and TCP connect timeouts.
server-poll-timeout 15

;remote-random
;local 192.168.1.\$((N%245+10))
nobind

ignore-unknown-option block-outside-dns dhcp-renew register-dns tap-sleep dhcp-release dhcp-option fragment

${mssfix}
tun-mtu 1500

client
dev tun
cipher AES-256-GCM
auth SHA256
compress
resolv-retry infinite
remote-cert-tls server
sndbuf 0
rcvbuf 0
reneg-sec 0
verb 3
;mute 5

# For single connection persist-* and user/group options can be uncommented
# For dual it's better to keep them commented, otherwise openvpn cannot
# change connection without full restart
;persist-key
;persist-tun
;persist-remote-ip
auth-nocache

\${OS_SPECIFIC_OPTIONS}

<connection>
remote ${SERVER_PUBLIC_IP} 1194 udp4
${fragment}
</connection>

<connection>
remote ${SERVER_PUBLIC_IP} 443 tcp4
</connection>

# Certificates and keys
<ca>
\$(< "\${SERVER_DIR}/keys/ca.crt")
</ca>
<cert>
\$(< "\${EASYRSA}/pki/issued/\${USER}.crt")
</cert>
<key>
\$(< "\${EASYRSA}/pki/private/\${USER}.key")
</key>
key-direction 1
<tls-auth>
\$(< "\${SERVER_DIR}/keys/ta.key")
</tls-auth>
EOF

read -rd '' NIX_SPECIFIC_OPTIONS <<'EOF'
# *nix specific options (Linux/Mac/BSD)
;user openvpn
;group openvpn
;nice 5
;log-append "/var/log/openvpn/\${USER}.log"
EOF
NIX_SPECIFIC_OPTIONS=\${NIX_SPECIFIC_OPTIONS/%\$'\n'}

read -rd '' WIN_SPECIFIC_OPTIONS <<'EOF'
# Windows specific options
block-outside-dns
dhcp-renew
register-dns
tap-sleep 1
EOF
WIN_SPECIFIC_OPTIONS=\${WIN_SPECIFIC_OPTIONS/%\$'\n'}

## Additional variables
# INITIAL_IROUTE_SUBNET=10.10.0.0/29
# LAST_IROUTE_SUBNET_FILE=\${SERVER_DIR}/last_iroute_subnet
# # Warning! Be careful - support of extended range of symbols could lead to script errors or unexpected behavior!
# HOST_NAME_ALLOWED_REGEX='^[A-Za-z0-9_-]+\$'  # Regex type of =~ bash operator (extended regular expression)
# ALLOW_DIFFERENT_CLIENT_TYPES_FOR_HOST=no

:  # For succesfull import
EOF_OPENVPN_MANAGE_CONF
echo "${OPENVPN_MANAGE_CONF}" >'/etc/openvpn/server/scripts/openvpn-manage.conf'


# To allow openvpn server listen on any IP uncomment line with `multihome` and comment `local` (comments is lines starts with ; or #) in openvpn server configs (and restart openvpn server).
read -rd '' UDP_SERVER_CONF <<EOF_UDP_SERVER_CONF
## OpenVPN 2.4 UDP server config file

# Must match IP of base network adapter
local ${SERVER_LOCAL_IP}
# OR if you want to allow openvpn server listen on all IP's
;multihome

# Base dir for options with relative paths
cd /etc/openvpn/chroot

## UDP server specific options
proto udp4
dev tun0
# Keep client IP for a day (86400)
;ifconfig-pool-persist ipp.udp.server.txt 86400
# Make replay-window larger due to possible laggy clients (defaults: 64 15)
replay-window 80 20
fast-io
${mssfix}
tun-mtu 1500
${fragment}
;connect-freq 20 1
status /var/log/openvpn/status.udp.server.txt 10
# journalctl will be used for logging as well
log-append /var/log/openvpn/udp.server.log
replay-persist replay-persist.udp.server.txt
# Management interface
;management /run/openvpn/mgmt.udp.server.socket unix
opt-verify
## END UDP server specific options

lport 1194
server 172.16.16.0 255.255.255.0 nopool
ifconfig-pool 172.16.16.0 172.16.16.254 255.255.255.0
# If you want traffic between clients go through firewall do not enable client-to-client
;client-to-client

topology subnet
;txqueuelen 500
status-version 1
tls-timeout 2

# On client side reneg-sec set to 0 by default,
# so this value (lowest positive) will be really used for most users
# 14400: 4h (default 3600: 1h)
reneg-sec 3600

ca /etc/openvpn/server/keys/ca.crt
cert /etc/openvpn/server/keys/server.crt
key /etc/openvpn/server/keys/server.key
dh /etc/openvpn/server/keys/dh.pem
crl-verify crl.pem
# tls-auth, replay-persist, connect-freq are good for basic DDoS protection
tls-auth /etc/openvpn/server/keys/ta.key 0

# Decrease openvpn process priority
;nice 5

# Generally it's good to set proper max-clients value to avoid server freeze
max-clients 1024
;hash-size 1024 1024
;bcast-buffers 128

;management-client-user openvpn
;management-client-group openvpn

# Use separate user
user openvpn
group openvpn

cipher AES-256-GCM
auth SHA256
tls-cipher TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-RSA-WITH-AES-256-CBC-SHA256:TLS-DHE-RSA-WITH-AES-256-GCM-SHA384
tls-version-min 1.2

;script-security 1
script-security 2
learn-address scripts/learn-address
;client-connect scripts/client-connect
;client-disconnect scripts/client-disconnect
ccd-exclusive
client-config-dir ccd
tmp-dir tmp

mute-replay-warnings
verb 4

keepalive 10 40
persist-key
persist-tun
persist-local-ip

compress lz4
push "compress lz4"

# For additional options see /etc/openvpn/server/users-config
# and per client configs in client-config-dir

chroot /etc/openvpn/chroot
EOF_UDP_SERVER_CONF
echo "${UDP_SERVER_CONF}" >'/etc/openvpn/server/udp.server.conf'

read -rd '' TCP_SERVER_CONF <<EOF_TCP_SERVER_CONF
## OpenVPN 2.4 TCP server config file

# Must match IP of base network adapter
local ${SERVER_LOCAL_IP}
# OR if you want to allow openvpn server listen on all IP's
;multihome

# Base dir for options with relative paths
cd /etc/openvpn/chroot

## TCP server specific options
proto tcp4
dev tun1
# Keep client IP for a day (86400)
;ifconfig-pool-persist ipp.tcp.server.txt 86400
${mssfix}
tun-mtu 1500
tcp-nodelay
tcp-queue-limit 64
status /var/log/openvpn/status.tcp.server.txt 10
# journalctl will be used for logging as well
log-append /var/log/openvpn/tcp.server.log
replay-persist replay-persist.tcp.server.txt
# Management interface
;management /run/openvpn/mgmt.tcp.server.socket unix
;opt-verify
## END TCP server specific options

lport 443
server 172.16.16.0 255.255.255.0 nopool
ifconfig-pool 172.16.16.0 172.16.16.254 255.255.255.0
# If you want traffic between clients go through firewall do not enable client-to-client
;client-to-client

topology subnet
;txqueuelen 500
status-version 1
tls-timeout 2

# On client side reneg-sec set to 0 by default,
# so this value (lowest positive) will be really used for most users
# 14400: 4h (default 3600: 1h)
reneg-sec 3600

ca /etc/openvpn/server/keys/ca.crt
cert /etc/openvpn/server/keys/server.crt
key /etc/openvpn/server/keys/server.key
dh /etc/openvpn/server/keys/dh.pem
crl-verify crl.pem
# tls-auth, replay-persist, connect-freq are good for basic DDoS protection
tls-auth /etc/openvpn/server/keys/ta.key 0

# Decrease openvpn process priority
;nice 5

# Generally it's good to set proper max-clients value to avoid server freeze
max-clients 1024
;hash-size 1024 1024
;bcast-buffers 128

;management-client-user openvpn
;management-client-group openvpn

# Use separate user
user openvpn
group openvpn

cipher AES-256-GCM
auth SHA256
tls-cipher TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-DHE-RSA-WITH-AES-256-CBC-SHA256:TLS-DHE-RSA-WITH-AES-256-GCM-SHA384
tls-version-min 1.2

;script-security 1
script-security 2
learn-address scripts/learn-address
;client-connect scripts/client-connect
;client-disconnect scripts/client-disconnect
ccd-exclusive
client-config-dir ccd
tmp-dir tmp

mute-replay-warnings
verb 4

keepalive 10 40
persist-key
persist-tun
persist-local-ip

compress lz4
push "compress lz4"

# For additional options see /etc/openvpn/server/users-config
# and per client configs in client-config-dir

chroot /etc/openvpn/chroot
EOF_TCP_SERVER_CONF
echo "${TCP_SERVER_CONF}" >'/etc/openvpn/server/tcp.server.conf'
## END Create configs

## Configure SELinux if required
if hash sestatus 2>/dev/null && sestatus | grep -q 'SELinux status:\s\+enabled'; then
    echo 'SELinux enabled, creating the rule to allow openvpn server to run on non standard UDP port 1194...'
    hash semanage 2>/dev/null || yum -y -d0 install policycoreutils-python
    semanage port -a -t openvpn_port_t -p udp 1194
    # TODO: sort out if the above does not work
    # If does not work, this can help (but it's less secure):
    #setenforce 0
    # For permanent fix set /etc/selinux/config:SELINUX=permissive
fi

echo 'Stop/Start OpenVPN server'
if pidof systemd >/dev/null; then  # CentOS 7, Ubuntu Xenial
    systemctl stop openvpn@udp.server.service
    systemctl stop openvpn@tcp.server.service
    systemctl start openvpn@udp.server.service
    systemctl start openvpn@tcp.server.service
else  # CentOS 6, Ubuntu Trusty
    service openvpn stop
    service openvpn start
fi
echo 'Sleeping for 5 sec to give openvpn server time to start...'
sleep 5

## Check log
echo $'\n''Tail of udp.server.log:'
tail /var/log/openvpn/udp.server.log
echo $'\n''Tail of tcp.server.log:'
tail /var/log/openvpn/tcp.server.log
echo

read -rd '' IPTABLES_RULES <<EOF_IPTABLES_RULES
## Forwarding setup
iptables -P FORWARD DROP
iptables -I FORWARD -i tun+ -o ${SERVER_LOCAL_IF} -j ACCEPT
iptables -I FORWARD -i ${SERVER_LOCAL_IF} -o tun+ -j ACCEPT

## Enable SNAT (default). For dynamic server IP use "-j MASQUERADE" instead of "-j SNAT ..."
iptables -t nat -A POSTROUTING -o ${SERVER_LOCAL_IF}  -j SNAT --to-source ${SERVER_LOCAL_IP}
## Different SNAT for specific VPN clients. E.g.:
# iptables -t nat -I POSTROUTING -s 172.16.16.2 -o ${SERVER_LOCAL_IF}  -j SNAT --to-source SERVER_LOCAL_IP1
# iptables -t nat -I POSTROUTING -s 172.16.16.3 -o ${SERVER_LOCAL_IF}  -j SNAT --to-source SERVER_LOCAL_IP2
# iptables -t nat -I POSTROUTING -s 172.16.16.4 -o ${SERVER_LOCAL_IF}  -j SNAT --to-source SERVER_LOCAL_IP3
# ...

## Open ports (if required)
iptables -I INPUT 1 -p udp --dport 1194 -i ${SERVER_LOCAL_IF} -j ACCEPT
iptables -I INPUT 1 -p tcp --dport 443 -i ${SERVER_LOCAL_IF} -j ACCEPT
EOF_IPTABLES_RULES

echo 'Evaluate iptables rules and save'
# Evaluate
eval "${IPTABLES_RULES}"
# Save
if [[ "${OS_family}" == 'RedHat' ]]; then
    service iptables save
else
    netfilter-persistent save
    netfilter-persistent reload
fi

# echo 'Setup /etc/rc.local for forwarding'
# sed -i 's/^exit 0$//' /etc/rc.local
# comment='OpenVPN forwarding'
# sed -i "/^# ${comment}/,/^# END ${comment}/d" /etc/rc.local  # Remove OpenVPN forwarding rules from rc.local
# IPTABLES_RULES_COMMENTED=${IPTABLES_RULES//$'\n'/$'\n'# }
# read -rd '' RC_LOCAL <<EOF_RC_LOCAL
# ## ${comment}
# echo 1 >/proc/sys/net/ipv4/ip_forward

# # Saved to /etc/sysconfig/iptables, so commented here
# # ${IPTABLES_RULES_COMMENTED}
# ## END ${comment}

# exit 0
# EOF_RC_LOCAL
# echo $'\n'"${RC_LOCAL}" >>/etc/rc.local
echo 1 >/proc/sys/net/ipv4/ip_forward
if grep -q 'net.ipv4.ip_forward' /etc/sysctl.conf; then
    sed -i 's/^\s*#\s*net.ipv4.ip_forward\s*=.*$/net.ipv4.ip_forward=1/' /etc/sysctl.conf
else
    echo $'\n''# Enable IPv4 forwarding'$'\n''net.ipv4.ip_forward=1' >>/etc/sysctl.conf
fi

# echo 'It is possible that you need to adopt firewall (iptables rules) to your setup, refer comments in /etc/rc.local'

echo '
Make sure you have opened ports for openvpn server in VPS firewall (443 tcp and 1194 udp in this case)
If your VM/VPS has local firewall rules you probably have to change iptables rules to fit them and save them.
'
echo 'Firewall status:'
# iptables -vnL; echo; iptables -vnL -t nat
if ((CentOS_major == 6)); then
    service iptables status
else
    iptables -vnL
    echo $'\n'
    iptables -t nat -vnL
fi

## Create client certs/configs
# echo 'Creating test openvpn user:'
# openvpn-manage create test
echo 'To add users use: sudo openvpn-manage create usernamehere'
echo 'For help run openvpn-manage without arguments'
echo 'To download all configs locally you can run on your PC:'${BR}"scp root@${SERVER_PUBLIC_IP}:/etc/openvpn/server/client-packs/*/*.*[fn] ./"

echo 'Configuration completed'
